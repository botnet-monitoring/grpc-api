// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: storage.proto

package gen

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on SessionToken with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SessionToken) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SessionToken with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SessionTokenMultiError, or
// nil if none found.
func (m *SessionToken) ValidateAll() error {
	return m.validate(true)
}

func (m *SessionToken) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	if len(errors) > 0 {
		return SessionTokenMultiError(errors)
	}

	return nil
}

// SessionTokenMultiError is an error wrapping multiple validation errors
// returned by SessionToken.ValidateAll() if the designated constraints aren't met.
type SessionTokenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SessionTokenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SessionTokenMultiError) AllErrors() []error { return m }

// SessionTokenValidationError is the validation error returned by
// SessionToken.Validate if the designated constraints aren't met.
type SessionTokenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionTokenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionTokenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionTokenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionTokenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionTokenValidationError) ErrorName() string { return "SessionTokenValidationError" }

// Error satisfies the builtin error interface
func (e SessionTokenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSessionToken.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionTokenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionTokenValidationError{}

// Validate checks the field values on RegisterSessionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterSessionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterSessionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterSessionRequestMultiError, or nil if none found.
func (m *RegisterSessionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterSessionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BotnetId

	if m.CampaignId != nil {
		// no validation rules for CampaignId
	}

	if m.Frequency != nil {
		// no validation rules for Frequency
	}

	if m.PublicIp != nil {

		if all {
			switch v := interface{}(m.GetPublicIp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RegisterSessionRequestValidationError{
						field:  "PublicIp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RegisterSessionRequestValidationError{
						field:  "PublicIp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPublicIp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RegisterSessionRequestValidationError{
					field:  "PublicIp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.MonitorPort != nil {

		if all {
			switch v := interface{}(m.GetMonitorPort()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RegisterSessionRequestValidationError{
						field:  "MonitorPort",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RegisterSessionRequestValidationError{
						field:  "MonitorPort",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMonitorPort()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RegisterSessionRequestValidationError{
					field:  "MonitorPort",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.ConfigJson != nil {

		if all {
			switch v := interface{}(m.GetConfigJson()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RegisterSessionRequestValidationError{
						field:  "ConfigJson",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RegisterSessionRequestValidationError{
						field:  "ConfigJson",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConfigJson()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RegisterSessionRequestValidationError{
					field:  "ConfigJson",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RegisterSessionRequestMultiError(errors)
	}

	return nil
}

// RegisterSessionRequestMultiError is an error wrapping multiple validation
// errors returned by RegisterSessionRequest.ValidateAll() if the designated
// constraints aren't met.
type RegisterSessionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterSessionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterSessionRequestMultiError) AllErrors() []error { return m }

// RegisterSessionRequestValidationError is the validation error returned by
// RegisterSessionRequest.Validate if the designated constraints aren't met.
type RegisterSessionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterSessionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterSessionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterSessionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterSessionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterSessionRequestValidationError) ErrorName() string {
	return "RegisterSessionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterSessionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterSessionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterSessionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterSessionRequestValidationError{}

// Validate checks the field values on RegisterSessionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterSessionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterSessionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterSessionResponseMultiError, or nil if none found.
func (m *RegisterSessionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterSessionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSessionToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterSessionResponseValidationError{
					field:  "SessionToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterSessionResponseValidationError{
					field:  "SessionToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSessionToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterSessionResponseValidationError{
				field:  "SessionToken",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SessionTimeout

	if m.LastInsertedBotReply != nil {

		if all {
			switch v := interface{}(m.GetLastInsertedBotReply()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RegisterSessionResponseValidationError{
						field:  "LastInsertedBotReply",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RegisterSessionResponseValidationError{
						field:  "LastInsertedBotReply",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLastInsertedBotReply()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RegisterSessionResponseValidationError{
					field:  "LastInsertedBotReply",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.LastInsertedFailedTry != nil {

		if all {
			switch v := interface{}(m.GetLastInsertedFailedTry()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RegisterSessionResponseValidationError{
						field:  "LastInsertedFailedTry",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RegisterSessionResponseValidationError{
						field:  "LastInsertedFailedTry",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLastInsertedFailedTry()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RegisterSessionResponseValidationError{
					field:  "LastInsertedFailedTry",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.LastInsertedEdge != nil {

		if all {
			switch v := interface{}(m.GetLastInsertedEdge()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RegisterSessionResponseValidationError{
						field:  "LastInsertedEdge",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RegisterSessionResponseValidationError{
						field:  "LastInsertedEdge",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLastInsertedEdge()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RegisterSessionResponseValidationError{
					field:  "LastInsertedEdge",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RegisterSessionResponseMultiError(errors)
	}

	return nil
}

// RegisterSessionResponseMultiError is an error wrapping multiple validation
// errors returned by RegisterSessionResponse.ValidateAll() if the designated
// constraints aren't met.
type RegisterSessionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterSessionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterSessionResponseMultiError) AllErrors() []error { return m }

// RegisterSessionResponseValidationError is the validation error returned by
// RegisterSessionResponse.Validate if the designated constraints aren't met.
type RegisterSessionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterSessionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterSessionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterSessionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterSessionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterSessionResponseValidationError) ErrorName() string {
	return "RegisterSessionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterSessionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterSessionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterSessionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterSessionResponseValidationError{}

// Validate checks the field values on DatedBotReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DatedBotReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DatedBotReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DatedBotReplyMultiError, or
// nil if none found.
func (m *DatedBotReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DatedBotReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatedBotReplyValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatedBotReplyValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatedBotReplyValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatedBotReplyValidationError{
					field:  "Ip",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatedBotReplyValidationError{
					field:  "Ip",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatedBotReplyValidationError{
				field:  "Ip",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatedBotReplyValidationError{
					field:  "Port",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatedBotReplyValidationError{
					field:  "Port",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatedBotReplyValidationError{
				field:  "Port",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.BotId != nil {
		// no validation rules for BotId
	}

	if m.OtherData != nil {

		if all {
			switch v := interface{}(m.GetOtherData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DatedBotReplyValidationError{
						field:  "OtherData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DatedBotReplyValidationError{
						field:  "OtherData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOtherData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DatedBotReplyValidationError{
					field:  "OtherData",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DatedBotReplyMultiError(errors)
	}

	return nil
}

// DatedBotReplyMultiError is an error wrapping multiple validation errors
// returned by DatedBotReply.ValidateAll() if the designated constraints
// aren't met.
type DatedBotReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatedBotReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatedBotReplyMultiError) AllErrors() []error { return m }

// DatedBotReplyValidationError is the validation error returned by
// DatedBotReply.Validate if the designated constraints aren't met.
type DatedBotReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatedBotReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatedBotReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatedBotReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatedBotReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatedBotReplyValidationError) ErrorName() string { return "DatedBotReplyValidationError" }

// Error satisfies the builtin error interface
func (e DatedBotReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatedBotReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatedBotReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatedBotReplyValidationError{}

// Validate checks the field values on StoreDatedBotReplyBatchRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StoreDatedBotReplyBatchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StoreDatedBotReplyBatchRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// StoreDatedBotReplyBatchRequestMultiError, or nil if none found.
func (m *StoreDatedBotReplyBatchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StoreDatedBotReplyBatchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BatchId

	for idx, item := range m.GetReplies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StoreDatedBotReplyBatchRequestValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StoreDatedBotReplyBatchRequestValidationError{
						field:  fmt.Sprintf("Replies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StoreDatedBotReplyBatchRequestValidationError{
					field:  fmt.Sprintf("Replies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StoreDatedBotReplyBatchRequestMultiError(errors)
	}

	return nil
}

// StoreDatedBotReplyBatchRequestMultiError is an error wrapping multiple
// validation errors returned by StoreDatedBotReplyBatchRequest.ValidateAll()
// if the designated constraints aren't met.
type StoreDatedBotReplyBatchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StoreDatedBotReplyBatchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StoreDatedBotReplyBatchRequestMultiError) AllErrors() []error { return m }

// StoreDatedBotReplyBatchRequestValidationError is the validation error
// returned by StoreDatedBotReplyBatchRequest.Validate if the designated
// constraints aren't met.
type StoreDatedBotReplyBatchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StoreDatedBotReplyBatchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StoreDatedBotReplyBatchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StoreDatedBotReplyBatchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StoreDatedBotReplyBatchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StoreDatedBotReplyBatchRequestValidationError) ErrorName() string {
	return "StoreDatedBotReplyBatchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StoreDatedBotReplyBatchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStoreDatedBotReplyBatchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StoreDatedBotReplyBatchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StoreDatedBotReplyBatchRequestValidationError{}

// Validate checks the field values on StoreDatedBotReplyBatchResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StoreDatedBotReplyBatchResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StoreDatedBotReplyBatchResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// StoreDatedBotReplyBatchResponseMultiError, or nil if none found.
func (m *StoreDatedBotReplyBatchResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StoreDatedBotReplyBatchResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BatchId

	if len(errors) > 0 {
		return StoreDatedBotReplyBatchResponseMultiError(errors)
	}

	return nil
}

// StoreDatedBotReplyBatchResponseMultiError is an error wrapping multiple
// validation errors returned by StoreDatedBotReplyBatchResponse.ValidateAll()
// if the designated constraints aren't met.
type StoreDatedBotReplyBatchResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StoreDatedBotReplyBatchResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StoreDatedBotReplyBatchResponseMultiError) AllErrors() []error { return m }

// StoreDatedBotReplyBatchResponseValidationError is the validation error
// returned by StoreDatedBotReplyBatchResponse.Validate if the designated
// constraints aren't met.
type StoreDatedBotReplyBatchResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StoreDatedBotReplyBatchResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StoreDatedBotReplyBatchResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StoreDatedBotReplyBatchResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StoreDatedBotReplyBatchResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StoreDatedBotReplyBatchResponseValidationError) ErrorName() string {
	return "StoreDatedBotReplyBatchResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StoreDatedBotReplyBatchResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStoreDatedBotReplyBatchResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StoreDatedBotReplyBatchResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StoreDatedBotReplyBatchResponseValidationError{}

// Validate checks the field values on DatedFailedTry with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DatedFailedTry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DatedFailedTry with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DatedFailedTryMultiError,
// or nil if none found.
func (m *DatedFailedTry) ValidateAll() error {
	return m.validate(true)
}

func (m *DatedFailedTry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatedFailedTryValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatedFailedTryValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatedFailedTryValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatedFailedTryValidationError{
					field:  "Ip",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatedFailedTryValidationError{
					field:  "Ip",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatedFailedTryValidationError{
				field:  "Ip",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatedFailedTryValidationError{
					field:  "Port",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatedFailedTryValidationError{
					field:  "Port",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatedFailedTryValidationError{
				field:  "Port",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.BotId != nil {
		// no validation rules for BotId
	}

	if m.Reason != nil {
		// no validation rules for Reason
	}

	if m.OtherData != nil {

		if all {
			switch v := interface{}(m.GetOtherData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DatedFailedTryValidationError{
						field:  "OtherData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DatedFailedTryValidationError{
						field:  "OtherData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOtherData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DatedFailedTryValidationError{
					field:  "OtherData",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DatedFailedTryMultiError(errors)
	}

	return nil
}

// DatedFailedTryMultiError is an error wrapping multiple validation errors
// returned by DatedFailedTry.ValidateAll() if the designated constraints
// aren't met.
type DatedFailedTryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatedFailedTryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatedFailedTryMultiError) AllErrors() []error { return m }

// DatedFailedTryValidationError is the validation error returned by
// DatedFailedTry.Validate if the designated constraints aren't met.
type DatedFailedTryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatedFailedTryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatedFailedTryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatedFailedTryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatedFailedTryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatedFailedTryValidationError) ErrorName() string { return "DatedFailedTryValidationError" }

// Error satisfies the builtin error interface
func (e DatedFailedTryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatedFailedTry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatedFailedTryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatedFailedTryValidationError{}

// Validate checks the field values on StoreDatedFailedTryBatchRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StoreDatedFailedTryBatchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StoreDatedFailedTryBatchRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// StoreDatedFailedTryBatchRequestMultiError, or nil if none found.
func (m *StoreDatedFailedTryBatchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StoreDatedFailedTryBatchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BatchId

	for idx, item := range m.GetTries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StoreDatedFailedTryBatchRequestValidationError{
						field:  fmt.Sprintf("Tries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StoreDatedFailedTryBatchRequestValidationError{
						field:  fmt.Sprintf("Tries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StoreDatedFailedTryBatchRequestValidationError{
					field:  fmt.Sprintf("Tries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StoreDatedFailedTryBatchRequestMultiError(errors)
	}

	return nil
}

// StoreDatedFailedTryBatchRequestMultiError is an error wrapping multiple
// validation errors returned by StoreDatedFailedTryBatchRequest.ValidateAll()
// if the designated constraints aren't met.
type StoreDatedFailedTryBatchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StoreDatedFailedTryBatchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StoreDatedFailedTryBatchRequestMultiError) AllErrors() []error { return m }

// StoreDatedFailedTryBatchRequestValidationError is the validation error
// returned by StoreDatedFailedTryBatchRequest.Validate if the designated
// constraints aren't met.
type StoreDatedFailedTryBatchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StoreDatedFailedTryBatchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StoreDatedFailedTryBatchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StoreDatedFailedTryBatchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StoreDatedFailedTryBatchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StoreDatedFailedTryBatchRequestValidationError) ErrorName() string {
	return "StoreDatedFailedTryBatchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StoreDatedFailedTryBatchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStoreDatedFailedTryBatchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StoreDatedFailedTryBatchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StoreDatedFailedTryBatchRequestValidationError{}

// Validate checks the field values on StoreDatedFailedTryBatchResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *StoreDatedFailedTryBatchResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StoreDatedFailedTryBatchResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// StoreDatedFailedTryBatchResponseMultiError, or nil if none found.
func (m *StoreDatedFailedTryBatchResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StoreDatedFailedTryBatchResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BatchId

	if len(errors) > 0 {
		return StoreDatedFailedTryBatchResponseMultiError(errors)
	}

	return nil
}

// StoreDatedFailedTryBatchResponseMultiError is an error wrapping multiple
// validation errors returned by
// StoreDatedFailedTryBatchResponse.ValidateAll() if the designated
// constraints aren't met.
type StoreDatedFailedTryBatchResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StoreDatedFailedTryBatchResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StoreDatedFailedTryBatchResponseMultiError) AllErrors() []error { return m }

// StoreDatedFailedTryBatchResponseValidationError is the validation error
// returned by StoreDatedFailedTryBatchResponse.Validate if the designated
// constraints aren't met.
type StoreDatedFailedTryBatchResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StoreDatedFailedTryBatchResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StoreDatedFailedTryBatchResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StoreDatedFailedTryBatchResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StoreDatedFailedTryBatchResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StoreDatedFailedTryBatchResponseValidationError) ErrorName() string {
	return "StoreDatedFailedTryBatchResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StoreDatedFailedTryBatchResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStoreDatedFailedTryBatchResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StoreDatedFailedTryBatchResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StoreDatedFailedTryBatchResponseValidationError{}

// Validate checks the field values on DatedEdge with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DatedEdge) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DatedEdge with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DatedEdgeMultiError, or nil
// if none found.
func (m *DatedEdge) ValidateAll() error {
	return m.validate(true)
}

func (m *DatedEdge) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatedEdgeValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatedEdgeValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatedEdgeValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSrcIp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatedEdgeValidationError{
					field:  "SrcIp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatedEdgeValidationError{
					field:  "SrcIp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSrcIp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatedEdgeValidationError{
				field:  "SrcIp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSrcPort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatedEdgeValidationError{
					field:  "SrcPort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatedEdgeValidationError{
					field:  "SrcPort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSrcPort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatedEdgeValidationError{
				field:  "SrcPort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDstIp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatedEdgeValidationError{
					field:  "DstIp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatedEdgeValidationError{
					field:  "DstIp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDstIp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatedEdgeValidationError{
				field:  "DstIp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDstPort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatedEdgeValidationError{
					field:  "DstPort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatedEdgeValidationError{
					field:  "DstPort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDstPort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatedEdgeValidationError{
				field:  "DstPort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.SrcBotId != nil {
		// no validation rules for SrcBotId
	}

	if m.DstBotId != nil {
		// no validation rules for DstBotId
	}

	if len(errors) > 0 {
		return DatedEdgeMultiError(errors)
	}

	return nil
}

// DatedEdgeMultiError is an error wrapping multiple validation errors returned
// by DatedEdge.ValidateAll() if the designated constraints aren't met.
type DatedEdgeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatedEdgeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatedEdgeMultiError) AllErrors() []error { return m }

// DatedEdgeValidationError is the validation error returned by
// DatedEdge.Validate if the designated constraints aren't met.
type DatedEdgeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatedEdgeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatedEdgeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatedEdgeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatedEdgeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatedEdgeValidationError) ErrorName() string { return "DatedEdgeValidationError" }

// Error satisfies the builtin error interface
func (e DatedEdgeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatedEdge.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatedEdgeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatedEdgeValidationError{}

// Validate checks the field values on StoreDatedEdgeBatchRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StoreDatedEdgeBatchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StoreDatedEdgeBatchRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StoreDatedEdgeBatchRequestMultiError, or nil if none found.
func (m *StoreDatedEdgeBatchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StoreDatedEdgeBatchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BatchId

	for idx, item := range m.GetEdges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StoreDatedEdgeBatchRequestValidationError{
						field:  fmt.Sprintf("Edges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StoreDatedEdgeBatchRequestValidationError{
						field:  fmt.Sprintf("Edges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StoreDatedEdgeBatchRequestValidationError{
					field:  fmt.Sprintf("Edges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StoreDatedEdgeBatchRequestMultiError(errors)
	}

	return nil
}

// StoreDatedEdgeBatchRequestMultiError is an error wrapping multiple
// validation errors returned by StoreDatedEdgeBatchRequest.ValidateAll() if
// the designated constraints aren't met.
type StoreDatedEdgeBatchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StoreDatedEdgeBatchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StoreDatedEdgeBatchRequestMultiError) AllErrors() []error { return m }

// StoreDatedEdgeBatchRequestValidationError is the validation error returned
// by StoreDatedEdgeBatchRequest.Validate if the designated constraints aren't met.
type StoreDatedEdgeBatchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StoreDatedEdgeBatchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StoreDatedEdgeBatchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StoreDatedEdgeBatchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StoreDatedEdgeBatchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StoreDatedEdgeBatchRequestValidationError) ErrorName() string {
	return "StoreDatedEdgeBatchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StoreDatedEdgeBatchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStoreDatedEdgeBatchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StoreDatedEdgeBatchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StoreDatedEdgeBatchRequestValidationError{}

// Validate checks the field values on StoreDatedEdgeBatchResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StoreDatedEdgeBatchResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StoreDatedEdgeBatchResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StoreDatedEdgeBatchResponseMultiError, or nil if none found.
func (m *StoreDatedEdgeBatchResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StoreDatedEdgeBatchResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BatchId

	if len(errors) > 0 {
		return StoreDatedEdgeBatchResponseMultiError(errors)
	}

	return nil
}

// StoreDatedEdgeBatchResponseMultiError is an error wrapping multiple
// validation errors returned by StoreDatedEdgeBatchResponse.ValidateAll() if
// the designated constraints aren't met.
type StoreDatedEdgeBatchResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StoreDatedEdgeBatchResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StoreDatedEdgeBatchResponseMultiError) AllErrors() []error { return m }

// StoreDatedEdgeBatchResponseValidationError is the validation error returned
// by StoreDatedEdgeBatchResponse.Validate if the designated constraints
// aren't met.
type StoreDatedEdgeBatchResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StoreDatedEdgeBatchResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StoreDatedEdgeBatchResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StoreDatedEdgeBatchResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StoreDatedEdgeBatchResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StoreDatedEdgeBatchResponseValidationError) ErrorName() string {
	return "StoreDatedEdgeBatchResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StoreDatedEdgeBatchResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStoreDatedEdgeBatchResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StoreDatedEdgeBatchResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StoreDatedEdgeBatchResponseValidationError{}

// Validate checks the field values on DisconnectRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DisconnectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisconnectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DisconnectRequestMultiError, or nil if none found.
func (m *DisconnectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DisconnectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Reason

	if len(errors) > 0 {
		return DisconnectRequestMultiError(errors)
	}

	return nil
}

// DisconnectRequestMultiError is an error wrapping multiple validation errors
// returned by DisconnectRequest.ValidateAll() if the designated constraints
// aren't met.
type DisconnectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisconnectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisconnectRequestMultiError) AllErrors() []error { return m }

// DisconnectRequestValidationError is the validation error returned by
// DisconnectRequest.Validate if the designated constraints aren't met.
type DisconnectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisconnectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisconnectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisconnectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisconnectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisconnectRequestValidationError) ErrorName() string {
	return "DisconnectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DisconnectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisconnectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisconnectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisconnectRequestValidationError{}

// Validate checks the field values on DisconnectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DisconnectResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisconnectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DisconnectResponseMultiError, or nil if none found.
func (m *DisconnectResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DisconnectResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DisconnectResponseMultiError(errors)
	}

	return nil
}

// DisconnectResponseMultiError is an error wrapping multiple validation errors
// returned by DisconnectResponse.ValidateAll() if the designated constraints
// aren't met.
type DisconnectResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisconnectResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisconnectResponseMultiError) AllErrors() []error { return m }

// DisconnectResponseValidationError is the validation error returned by
// DisconnectResponse.Validate if the designated constraints aren't met.
type DisconnectResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisconnectResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisconnectResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisconnectResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisconnectResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisconnectResponseValidationError) ErrorName() string {
	return "DisconnectResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DisconnectResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisconnectResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisconnectResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisconnectResponseValidationError{}
